text = "The factory is a design pattern that I use really often when I write software.  Today I'm going to show you an example of how it works and how you can use it to separate  creation from use, which is really powerful.  Before we dive in, I have something for you.  I wrote down the seven main things that I think about when designing a new feature or  new software application.  You can get it for free at rnco.com-designguide.  It's pretty short, so PDF contains a couple of bullet points,  some notes for me here and there I think you'll find it really useful.  So, get it at rnco.com-designguide.  Now, let's dive into the factory pattern.  What we have here is a video in audio exporting example.  As you can see, I did a little bit of preparation work.  I created a video explorer abstract class that's a basic representation of a video exporting codec.  And that has two methods.  Prepare export and do the export.  Prepare export gets the actual video data and do export gets folder.  I'm using the pathlip.path type here to represent paths.  And that exports the video data to folder, at least that's the idea.  And then we have several specific implementations for this class.  There is a lossless video explorer that export data and lossless formats.  There's also an H264 video exporting codec with baseline profiles that's  a economic mode, lower quality.  And finally, there is a higher quality H264 export format with 4 to 2 Chroma sampling and 10 bit  colors and stuff like that.  Doesn't really matter for this example, but it's a higher quality one.  And a similar thing I did for the audio explorer.  We have an audio explorer abstract class that has prepared export and do the export,  but that gets audio data, but do export also gets folder.  So it looks a bit similar.  And then there is an AAC audio exporting codec and we have a wave audio  exported which is lossless.  So again, also here we have kind of a lower economic quality and a high quality  that you would use for masters.  Then there is a main function that first reads the export quality that the user wants.  So we ask the user whether they want low high or master.  And then depending on that value that you got, we're going to create these specific  exporters.  So we start with these variables.  Video and audio exporter.  If the quality is low, we're creating the base profile H264,  video exporter and the AAC audio explorer.  If the quality is high, we're using the high quality profile for video and also AAC.  If it's master quality, then we're going for lossless video and lossless.  Audio in the form of a wave file.  So the choice of the kind of export that one uses here.  Then we call the function, we prepare the exports and we do the actual export to a particular folder.  So let's run this code and see what happens.  So now you can enter and decide output quality.  If I choose low, then it's going to export with the H64 baseline export and AAC export.  And if I run this again and I choose for example master quality,  then I'm getting the video and audio export in master quality.  Now if you look at this code, you see the desk in particular a problem with the main function.  And that it has way too many responsibilities.  It's responsible for asking the user which quality they want.  It's responsible for then mapping that desired quality to actual objects.  And then it does the actual export, which is a lot of different things.  So main has weak or low cohesion at the moment.  It does a lot of different things.  It also has a lot of coupling because main is creating all these specific instances of video on audio  exporters. So that means main needs to know about the existence of all these different classes.  And in this example we may have two or three audio video exporters.  But if you have any serious video or the audio editing program, you're going to have many different  export formats and it's going to lead to lots and lots of different classes.  And that's going to lead to lots and lots of complicated if else statements.  Another thing is that because the way this is set up is that we don't really have the option to  create our own custom export formats. So now we have low high and master, but maybe we want a  high audio quality, low video quality option or we want something else.  And that's also a really hard to add at the moment.  The factory pattern is a classic from the Gang of Four Design Patterns book.  The goal of the pattern is to help write code that separates creation from use.  In other words, you should create your objects in a different place than where you use them.  This is very helpful because then the code that you write doesn't have to know anything about  how the objects are created when you use them. And that means that if in a later stage you  decide to change out those objects by other objects, you don't have to change the original code.  What the factory does is that it takes care of the creation for you so that you can use those  objects without knowing the specifics. And the way that it works is that we need to create and  in this case an export or factory that gives us the objects that we need. So let's start there  and let's create an exportor factory that can give us a video exportor and an audio exporter.  That's an abstract base class.  The factory is going to have two methods, one method that gives us a video exporter and one method that  gives us an audio exporter.  You see it's useful that we already have these abstract classes for video and audio exporters.  That makes the job a lot easier. So get video exporter, get audio exporter and each of these returns  in new instance. So it's also helpful to write down in documentation that the factory is  actually not the owner of these things. You can do with them basically whatever you want. The factory  doesn't keep a reference to this instances. So let's write that down as well.  For Python it doesn't really matter that much because Python has reference counting so if you don't  use an object anymore it's going to be garbage collected automatically. But sometimes it's useful to  know that you don't have to tell the factory anything once you're done with the object you  are responsibility. So this is our exporter factory that's going to provide us with the instances  that we need. And now we can create concrete factories that are subclasses of this abstract  exporter factory. And this concrete factories are going to give us the objects that we need.  So for example we could create a low quality exporter factory or put a bit more positively fast  exporter. And that's a subclass of exporter factory and it's going to implement these methods here.  Copy that over. Let's also add a lockstring.  In this case the video exporter is going to be in H264 baseline video exporter because that's the faster one.  And the audio exporter is an AAC exporter. So this is our fast exporter.  Now we can also create a high quality exporter.  And that's going to give us an H264 high quality video exporter and an AC audio exporter as well.  And then that's also create a master quality exporter which is for the really high quality stuff.  And that's the slowest obviously so the video exporter is lossless and audio exporter is lossless  audio. Now we've created our three factories for low high and master therefore quality. Now let's  work the main function to increase the cohesion and separate out a bit and use this factory pattern.  So the first thing we're going to do is take this piece of code that's reading the desired  export quality from the user input and create a separate function that provides us with a specific factory  that they use once. So what I'm going to do is I'm going to remove this here and I'm going to  define another function called read exporter which is going to give us an exporter factory.  This stuff I'm going to put here is now instead of having a string value going to need to construct  an exporter factory. And here's a nice trick that you can do let's create a factories objects.  And that's a dictionary containing a factory for each of the quality types that want to have.  So low quality is a fast exporter. High quality is a high quality exporter and the master quality is a  master quality exporter. So we have our three factories now. And what we can do we don't need this  variable here anymore is that we're going to need to the while loop reading the export quality.  And here if the export quality is in one of these three things then we're going to return  the factory belong to it. There we go. And actually now this we can replace with  the dictionary. So now there's only one place where we're defining the factories that are available.  This gives us the exporter factory. Then in the main function we're going to create the factory.  And now that we have the factory we can retrieve the video and audio exporters.  Using the get video exporter and get audio exporter methods from the factory.  So now we have our video audio exporters and actually this stuff we don't need anymore.  So that's safe this and let's run the code. So we enter the desired quality high. And then it's  going to prepare the video and audio data in the format that we like to have.  And that's also a doom master quality. Now you see it's preparing and exporting the data in a  lossless format. If you look at the main function now you see that it's no longer responsible  for as many things. It's the only thing you need to do is retrieve the video on the audio  exporter from the factory and then actually do the export and that's it. And reading the export  is the function that's responsible for creating the factory that we want to use. For completeness let's  add a dox string. There we go. So we've been able to split the responsibility of reading the  exporter and then actually using the exporter separating creation from use. So these functions  now have much higher cohesion than in the first version. And the interesting thing is that there  is also less coupling because main no longer has to know anything about specific export codex  because that's all handled somewhere else. If a read export doesn't need to know that it only  needs to know about the factories that exist. There's one more thing we can do to improve this still  a bit which is that at the moment main is still responsible for reading the factory here using  read exporter and maybe we want to use the function in another setting where we're not reading the  export from the input. It's simply providing it. So what you can do to spice this up a bit is that  we actually provide the factory to the main function as an argument. So main gets a export factory.  This I'm going to remove here and we're going to put in here. There we go. So now it does exactly  the same except that main now gets the factory as an argument and we have more flexibility into  how we're going to provide that factory to the main function. This is a good example of using dependency  injection. It's something I talked about before because we're injecting the dependency on the factory  into the main function and even better we're even using dependency inversion here because the  factory itself here export a factory as you can see it's an abstract class. So main gets an abstract  class but we're creating a concrete factory so-class that main doesn't need to know anything about.  It only needs to know about the export of factory. Overall factories were really well if you want  separate creation from use and one of the strong points of factories is that they allow you to  group objects that belong together. In this example we have a low quality exporter setup and a  high quality exporter setup. So factories are really useful if you want to do something like this.  Another example of this is a web shop where you have settings per country like currency,  language, tax rates, shipping rates and those kind of things. Factories work less well if you want  to allow any combination of things. For example if you want to let the user define presets for  which combinations of codecs that the user wants. Because in that case you need to create a factory  class for every possible combination. If this is what you need then it's better to use a combination  of composition and dependency inversion because that overall gives you a little bit more flexibility  will still allowing for the lower coupling. But of course then you won't have the advantage of  being able to define specific factories before act. There's a recent video that I did about  dependency inversion that you could take a look at if you want to know how to do that. So I hope  you like this example. Let me know in the comments if the factory pattern is something that you  plan to use in your code. Subscribe to my channel if you haven't done so already. Thanks for watching.  Take care and see you in the next video."
